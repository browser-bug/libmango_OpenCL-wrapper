/*! \file
 *  \brief Task Graph
 */
#ifndef TASK_GRAPH_H
#define TASK_GRAPH_H

#include "kernel.h"

namespace mango {

/*! @name Task graph definition  */
///@{

/*! \brief A structure type representing a task graph 
 * \note The actual graph structure can be inferred by reading the
 * Kernel and Buffer objects, which include links to the readers
 * and writers.
 */
class TaskGraph {
public:
	TaskGraph(){};

/*! \brief Define a task graph
 * \param lkernels initialization vector of pointers to mango_kernel_t structures
 * representing the kernels in the task graph
 * \param lbuffers initialization vector of pointers to mango_buffer_t structures
 * representing the buffers in the task graph
 * \param levents initialization vector of pointers to mango_event_t structures
 * representing the synchronization events in the task graph
 */
	TaskGraph(
		std::initializer_list<std::shared_ptr<Kernel>> lkernels, 
		std::initializer_list<std::shared_ptr<Buffer>> lbuffers, 
		std::initializer_list<std::shared_ptr<Event>> levents={}) noexcept;
/*! \brief Define a task graph 
 * \param k number of kernels 
 * \param b number of buffers
 * \param e number of events
 * \param ... The variadic parameters must be exactly k mango_kernel_t *, b
 * mango_buffer_t *, and e mango_event_t *, representing the kernels, buffers
 * and events employed in this task graph.
 */
	TaskGraph(int k, int b, int e, ...);

/*! \brief Destroy a task graph
 */
	~TaskGraph();

/*! \brief Add a kernel to the task graph
 * \param kernel The kernel to add
 * \returns The task graph
 */
	inline TaskGraph & operator+=(std::shared_ptr<Kernel> kernel) { 
		kernels.push_back(kernel); 
		return *this;
	}

/*! \brief Remove a kernel from the task graph
 * \param kernel The kernel to add
 * \returns The task graph
 */
	inline TaskGraph & operator-=(std::shared_ptr<Kernel> kernel) {
		kernels.erase(std::remove(kernels.begin(), kernels.end(), kernel));
		return *this;
	}


/*! \brief Add a buffer to the task graph
 * \param buffer The buffer to add
 * \returns The task graph
 */
	inline TaskGraph & operator+=(std::shared_ptr<Buffer> buffer) {
		buffers.push_back(buffer);
		return *this;
	}

/*! \brief Remove a buffer from the task graph
 * \param buffer The buffer to add
 * \returns The task graph
 */
	inline TaskGraph & operator-=(std::shared_ptr<Buffer> buffer) { 
		buffers.erase(std::remove(buffers.begin(), buffers.end(), buffer));
		return *this;
	}

/*! \brief Add a event to the task graph
 * \param event The event to add
 * \returns The task graph
 */
	inline TaskGraph & operator+=(std::shared_ptr<Event> event) { 
		events.push_back(event);
		return *this;
	}

/*! \brief Remove a event from the task graph
 * \param event The event to add
 * \returns The task graph 
 */
	inline TaskGraph & operator-=(std::shared_ptr<Event> event) { 
		events.erase(std::remove(events.begin(), events.end(), event));
		return *this;
	}

	inline std::shared_ptr<Kernel> get_kernel_by_id(mango_id_t id) noexcept {
		return *find_if(this->kernels.begin(), this->kernels.end(), 
			[id] (const std::shared_ptr<Kernel>& k) { 
				return k->get_id() == id;
			} );
	}

	inline std::vector<std::shared_ptr<Kernel>> & get_kernels() noexcept {
		return this->kernels;
	}

	inline std::vector<std::shared_ptr<Buffer>> & get_buffers() noexcept {
		return this->buffers;
	}

	inline std::vector<std::shared_ptr<Event>> & get_events() noexcept {
		return this->events;
	}


private:
 	/*! List of kernels in the TaskGraph */
	std::vector<std::shared_ptr<Kernel>> kernels; 
	/*! List of buffers in the TaskGraph */ 
	std::vector<std::shared_ptr<Buffer>> buffers; 
	/*! List of events in the TaskGraph. Includes also events automatically 
	 * generated by the kernels and buffers.
	 */
	std::vector<std::shared_ptr<Event>> events; 


};
///@}

}
#endif /* TASK_GRAPH_H */
